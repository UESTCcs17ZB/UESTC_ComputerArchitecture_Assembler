add r1, r2, r3; // r1 = r2+r3
// 000000 000001 00000 00001 00010 00011
and r1, r2, r3; // r1 = r2&r3
// 000001 000001 00000 00001 00010 00011
or r1, r2, r3; // r1 = r2|r3
// 000001 000010 00000 00001 00010 00011
xor r1, r2, r3; // r1 = r2^|r3
// 000001 000100 00000 00001 00010 00011
srl r1, r2, 4; // r1 = r2>>4
// 000010 000010 00100 00001 00000 00010
sll r1, r2, 0b101; // r1 = r2<<5
// 000010 000011 00101 00001 00000 00010
addi r1, r2, 0xa; // r1 = r2+10
// 000101 0000000000001010 00010 00001
addi r1, r2, -7; // r1 = r2-7
// 000101 1111111111111001 00010 00001
andi r1, r2, 5; // r1 = r2&5
// 001001 0000000000000101 00010 00001
ori r1, r2, 4; // r1 = r2|4
// 001010 0000000000000100 00010 00001
xori r1, r2, 3; // r1 = r2^|3
// 001100 0000000000000011 00010 00001
load r1, 3(r2); // r1 = mem[r2+3]
// 001101 0000000000000011 00010 00001
load r1, -3(r2); // r1 = mem[r2-3]
// 001101 1111111111111101 00010 00001
store r1, 3(r2); // mem[r2+3] = r1
// 001110 0000000000000011 00010 00001
store r1, -3(r2); // mem[r2-3] = r1
// 001110 1111111111111101 00010 00001
beq r1, r2, 4; // if(r1==r2) PC = PC+4+(4<<2)
// 001111 0000000000000100 00001 00010
beq r1, r2, -0b1; // if(r1==r2) PC = PC+4+(-1<<2)
// 001111 1111111111111111 00001 00010
bne r1, r2, 4; // if(r1!=r2) PC = PC+4+(4<<2)
// 010000 0000000000000100 00001 00010
bne r1, r2, -0b1; // if(r1!=r2) PC = PC+4+(-1<<2)
// 010000 1111111111111111 00001 00010
jump 0x1c; // PC = (PC+4)[32:28] + 1c(16bit) + 00
// 010010 00000000000000000000011100
nop;
// 00000000 00000000 00000000 00000000

